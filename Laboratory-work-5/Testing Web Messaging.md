## Тестування Веб Повідомлень
| ID |
|:-:|
| WSTG-CLNT-11 |

### Короткий опис

Веб Повідомлення (також відомі як [Міжсторінкова комунікація](https://html.spec.whatwg.org/multipage/web-messaging.html#web-messaging)) дозволяють програмам, які працюють у різних доменах, безпечно спілкуватися. До введення Веб Повідомлень комунікація між різними джерелами (між iframe(кадр в кадрі), вкладками та вікнами) була обмежена політикою одного джерела і контролювалася браузером. Розробники використовували різні хаки(коди у файлі стилі якого застосовуються тільки до зазначених браузерам, а іншими ігнорується) для виконання цих завдань, але більшість з них були не безпечними.

Це обмеження в браузері призначене для запобігання зловмисному веб-сайту зчитувати конфіденційні дані з інших iframe(кадр в кадрі), вкладок тощо; однак існують випадки, коли два довірені веб-сайти повинні обмінюватися даними один з одним. Для вирішення цього завдання було введено міжсторінкову комунікацію в проекті специфікації [WHATWG HTML5](https://html.spec.whatwg.org/multipage/) та реалізовано в усіх основних браузерах. Вона забезпечує безпечну комунікацію між різними джерелами через iframe(кадр в кадрі), вкладки та вікна. 

API повідомлення ввів [метод `розміщенняПовідомлення()`](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage), за допомогою якого можна відправляти текстові повідомлення між джерелами. Він складається з двох параметрів: повідомлення та домен.  

Існують певні питання з безпеки при використанні `*` як домену, які обговорюються нижче. Щоб отримувати повідомлення, веб-сайт-одержувач повинен додати новий обробник подій, який має такі атрибути:
- Дані - вміст вхідного повідомлення;
- Походження документа-відправника; та
- Джерело - джерело вікна.

Ось приклад використання API повідомлень. Для відправлення повідомлення:
```
iframe1.contentWindow.postMessage("Привіт світ","http://www.example.com");
```
Для отримання повідомлення:
```
window.addEventListener("message", handler, true);
function handler(event) {
    if(event.origin === 'chat.example.com') {
        /* process message (event.data) */
    } else {
        /* ignore messages from untrusted domains */
    }
}
```

#### Безпека походження

Походження складається з схеми, імені хоста та порту. Воно однозначно ідентифікує домен, що відправляє або отримує повідомлення, і не включає частину URL або фрагмент. Наприклад, `https://example.com` буде вважатися відмінним від `http://example.com` через те, що схема першої - `https`, а другої - `http`. Те ж саме стосується веб-серверів, які працюють в одному домені, але на різних портах.

### Цілі Тестування
#### Перевірка Безпеки Вихідного Джерела

Тестувальники повинні перевірити, чи код додатка фільтрує та обробляє повідомлення від довірених доменів. Також в рамках домену-відправника варто переконатися, що домен-отримувач явно вказаний, і символ `*` не використовується як другий аргумент для методу `розміщенняПовідомлення()`. Ця практика може створювати загрози для безпеки і призвести до ситуацій, коли в разі перенаправлення або зміни походження іншими способами веб-сайт буде надсилати дані на невідомі сервери, і тим самим може викидати конфіденційні дані на зловмисні сервери.

Якщо веб-сайт не додає обмежень безпеки для доменів або походження, які мають право надсилати повідомлення на веб-сайт, існує велика ймовірність виникнення загрози для безпеки. Тестувальники повинні аналізувати код для слухачів подій повідомлень та вибирати функцію з методу `додатиОбробникПодій` для подальшого аналізу. Домени повинні завжди перевірятися перед обробкою даних.

#### Перевірка валідації(збір та оцінка даних) введення

Незважаючи на те, що веб-сайт теоретично приймає повідомлення лише з надійних доменів, дані все одно повинні розглядатися як зовнішні дані, ненадійні джерела і оброблюватися з використанням відповідних засобів безпеки. Тестувальники повинні проаналізувати код і шукати небезпечні методи, особливо там, де дані оцінюються за допомогою функції `оцінювати()` або вставляються в DOM за допомогою властивості `внутрішнійHTML`, що може призвести до вразливостей DOM-based XSS.

#### Статичний аналіз коду

JavaScript-код повинен бути проаналізований для визначення, як виконується веб-передача повідомлень. Зокрема, тестувальники повинні цікавитися тим, як обмежується приймання повідомлень з ненадійних доменів на веб-сайті і як дані обробляються, навіть для надійних доменів.

У цьому прикладі потрібний доступ для кожного піддомену (www, чат, форуми, ...) в межах домену owasp.org. Код намагається приймати будь-який домен з `.owasp.org`:
```
window.addEventListener("message", callback, true);

function callback(e) {
    if(e.origin.indexOf(".owasp.org")!=-1) {
        /* process message (e.data) */
    }
}
```

Намір полягає в тому, щоб дозволити такі субдомени, як:
- `www.owasp.org`
- `chat.owasp.org`
- `forums.owasp.org`

На жаль, це створює вразливі місця. Зловмисник може легко обійти фільтр, оскільки `www.owasp.org.attacker`.comвідповідатиме такий домен.

Ось приклад коду, у якому відсутня перевірка походження. Це дуже небезпечно, оскільки прийматиме введення з будь-якого домену:
```
window.addEventListener("message", callback, true);

function callback(e) {
        /* process message (e.data) */
}
```
Ось приклад уразливості підтвердження введення, яка може призвести до атаки XSS:
```
window.addEventListener("message", callback, true);

function callback(e) {
        if(e.origin === "trusted.domain.com") {
            element.innerHTML= e.data;
        }
}
```

Більш безпечним підходом було б використовувати властивість `внутрішнійТекст`замість `внутрішнійHTML`.

Щоб отримати додаткові ресурси OWASP щодо веб-повідомлень, перегляньте [Шпаргалку Безпеки OWASP HTML5](https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html)
